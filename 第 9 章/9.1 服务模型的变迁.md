<style>img {max-width: 500px} .w4{max-width: 500px}.w5{max-width: 500px}</style>

* Node实际是多线程;
  * Node自身还有一定的I/O线程存在，这些I/O线程由 **底层libuv** 处理
* JavaScript代码永远运行在V8上，是单线程的


## 石器时代:同步
> 它的服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。这意味除了当前的请求被处理外，其余请求都处于耽误的状态。它的处理能力相当低下，假设每次响应服务耗用的时间稳定为N秒，这类服务的QPS为1/N。
* QPS: 每秒处理的请求数


## 青铜时代:复制进程
> 为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用户。这样每个连接都需要一个进程来服务，即100个连接需要启动100个进程来进行服务，这是非常昂贵的代价。在进程复制的过程中，需要复制进程内部的状态，对于每个连接都进行这样的复制的话，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据， 启动是较为缓慢的。  
为了解决启动缓慢的问题，预复制(prefork)被引入服务模型中，即预先复制一定数量的进程。同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并发请求过高，内存使用随着进程数的增长将会被耗尽。  
假设通过进行复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为M，那这类服务的QPS为M/N。


## 白银时代:多线程
> 为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线 程池可以减少创建和销毁线程的开销。但是多线程所面临的并发问题只能说比多进程略好，因为每 个线程都拥有自己独立的堆栈，这个堆栈都需要占用一定的内存空间。另外，由于一个CPU核心在 一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀地 使用CPU资源，但是操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时， 时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。
如果忽略掉多线程上下文切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的影响，它的QPS则为M * L/N。
* **线程** 相对 **进程** 的开销要小许多，并且线程之间可以 共享数据
* Apache就是采用 **多线程/多进程** 模型实现的


## 黄金时代:事件驱动
> 为了解决高并发问题，基于事件驱动的服务模型出现了，像 **Node** 与 **Nginx** 均是基于事件驱动的方式实现的，采用单线程避免了不必要的内存开销和上下文切换开销。
* 事件驱动模式: Node 和 Nginx
* 优势: 内存开销小, 无上下文切换
* 劣势: 不能利用 多核CPU


